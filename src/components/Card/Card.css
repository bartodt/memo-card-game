.memory-card {
 width: var(--card-size);
 height: var(--card-size);
 perspective: 1000px;
 cursor: pointer;
 position: relative;
 transition: transform 0.2s;
 margin: auto;
}

/* Hover para cartas en estado normal */
.memory-card:not(.flipped):hover {
 transform: translateY(-5px) scale(1.05);
 box-shadow: 0 15px 30px var(--shadow-dark);
 transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275),
  box-shadow 0.3s ease;
}

/* Hover para cartas volteadas */
.memory-card.flipped:hover {
 transform: translateY(-5px);
 transition: transform 0.3s ease;
}

.memory-card.disabled {
 cursor: default;
 pointer-events: none;
}

.memory-card.disabled:hover {
 transform: none;
}

/* Estilo del efecto de barrido de luz */
.card-front::before,
.card-back::before {
 content: "";
 position: absolute;
 top: -50%;
 left: -100%;
 width: 80%;
 height: 200%;
 background: linear-gradient(
  to right,
  rgba(255, 255, 255, 0) 0%,
  rgba(255, 255, 255, 0.2) 20%,
  rgba(255, 255, 255, 0.5) 50%,
  rgba(255, 255, 255, 0.2) 80%,
  rgba(255, 255, 255, 0) 100%
 );
 transform: rotate(25deg);
 opacity: 0;
 z-index: 2;
 pointer-events: none;
}

/* Aplicar efecto de barrido en hover */
.memory-card:not(.flipped):hover .card-front::before {
 animation: lightSweep 1s ease-in-out;
 opacity: 1;
}

/* Aplicar efecto de barrido en hover para cartas volteadas */
.memory-card.flipped:hover .card-back::before {
 animation: lightSweep 1s ease-in-out;
 opacity: 1;
}

@keyframes lightSweep {
 0% {
  left: -150%;
  opacity: 1;
 }
 100% {
  left: 150%;
  opacity: 1;
 }
}

.card-inner {
 width: 100%;
 height: 100%;
 transition: transform 0.8s cubic-bezier(0.175, 0.885, 0.32, 1.275),
  box-shadow 0.3s ease, border 0.3s ease;
 transform-style: preserve-3d;
 position: relative;
 border-radius: 12px;
 box-shadow: 0 10px 25px var(--shadow-dark);
}

/* Mantener la rotación de las cartas volteadas durante el hover */
.memory-card.flipped .card-inner {
 transform: rotateY(180deg);
 box-shadow: 0 15px 30px var(--shadow-dark);
}

/* Override importante para evitar que se muestre el frente durante el hover */
.memory-card.flipped .card-front,
.memory-card.flipped:hover .card-front {
 backface-visibility: hidden !important;
 -webkit-backface-visibility: hidden !important;
 transform: rotateY(0deg);
}

/* Asegurar que el reverso permanezca visible durante el hover */
.memory-card.flipped .card-back,
.memory-card.flipped:hover .card-back {
 backface-visibility: visible !important;
 -webkit-backface-visibility: visible !important;
 transform: rotateY(180deg);
}

.memory-card.matched .card-inner {
 transform: rotateY(180deg);
 box-shadow: 0 0 25px var(--success);
 border: 3px solid var(--success);
 animation: matchedAnimation 1s ease-in-out forwards;
}

@keyframes matchedAnimation {
 0% {
  transform: rotateY(180deg) scale(1);
  box-shadow: 0 0 25px var(--success);
 }
 25% {
  transform: rotateY(180deg) scale(1.2);
  box-shadow: 0 0 40px var(--success);
 }
 50% {
  transform: rotateY(180deg) scale(1.1) rotate(10deg);
 }
 75% {
  transform: rotateY(180deg) scale(1.1) rotate(-10deg);
 }
 100% {
  transform: rotateY(180deg) scale(1);
  box-shadow: 0 0 15px var(--success);
 }
}

.memory-card.matched .card-back {
 background: linear-gradient(
  135deg,
  var(--success),
  var(--success-light)
 ) !important;
 color: white !important;
}

/* Agregar un barrido periódico para cartas emparejadas */
.memory-card.matched .card-back::before {
 animation: lightSweep 3s ease-in-out infinite;
 opacity: 1;
}

/* Quitar la animación anterior de brillo */
@keyframes card-shine-back {
 0% {
  filter: brightness(1) contrast(1);
 }
 50% {
  filter: brightness(1.2) contrast(1.05);
 }
 100% {
  filter: brightness(1) contrast(1);
 }
}

.card-front,
.card-back {
 width: 100%;
 height: 100%;
 position: absolute;
 backface-visibility: hidden !important;
 -webkit-backface-visibility: hidden !important;
 display: flex;
 align-items: center;
 justify-content: center;
 font-size: 28px;
 font-weight: bold;
 border-radius: 12px;
 user-select: none;
 transform-style: preserve-3d;
 overflow: hidden;
}

.card-front {
 background: linear-gradient(135deg, var(--primary), var(--secondary));
 color: white;
 box-shadow: inset 0 0 10px var(--shadow-dark);
 z-index: 1;
}

.card-front::after {
 content: "?";
 font-size: 36px;
 opacity: 0.9;
 text-shadow: 2px 2px 5px var(--shadow-darker);
}

.card-back {
 background: linear-gradient(135deg, var(--light), var(--card-back));
 color: var(--dark);
 transform: rotateY(180deg);
 border: 3px solid var(--light);
 opacity: 1;
 z-index: 0;
}

.memory-card.flipped .card-back {
 opacity: 1;
}

.card-value {
 display: block;
 opacity: 1;
 transform: rotateY(0deg);
 transition: none;
 will-change: auto;
 font-size: 28px;
 text-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
}

.dark-theme .card-back {
 background: linear-gradient(135deg, #2c2c2c, #2c3e50);
 color: white;
 border: 2px solidwhite;
}

.dark-theme .memory-card.matched .card-back {
 background: linear-gradient(
  135deg,
  var(--success-dark-theme),
  var(--success-light-dark-theme)
 ) !important;
 color: white !important;
}

.card-inner::before {
 display: none;
}

@media (max-width: 600px) {
 :root {
  --card-size: 80px;
 }

 .card-front::after {
  font-size: 28px;
 }

 .card-value {
  font-size: 22px;
 }
}

/* Añadir borde brillante pulsante */
.memory-card:hover .card-inner::after {
 content: "";
 position: absolute;
 top: -2px;
 left: -2px;
 right: -2px;
 bottom: -2px;
 border: 2px solid rgba(255, 255, 255, 0.6);
 border-radius: 14px;
 animation: pulseBorder 1.5s infinite;
 pointer-events: none;
}

@keyframes pulseBorder {
 0% {
  opacity: 0.6;
  box-shadow: 0 0 5px rgba(255, 255, 255, 0.6);
 }
 50% {
  opacity: 0.9;
  box-shadow: 0 0 15px rgba(255, 255, 255, 0.8);
 }
 100% {
  opacity: 0.6;
  box-shadow: 0 0 5px rgba(255, 255, 255, 0.6);
 }
}

/* Efecto de levitación para cartas emparejadas */
.memory-card.matched {
 animation: float 3s ease-in-out infinite;
}

@keyframes float {
 0% {
  transform: translateY(0) rotateY(180deg);
 }
 50% {
  transform: translateY(-10px) rotateY(180deg);
 }
 100% {
  transform: translateY(0) rotateY(180deg);
 }
}

/* Agregar clase shake en JavaScript cuando la coincidencia es incorrecta */
.memory-card.shake {
 animation: shakeCard 0.5s;
}

@keyframes shakeCard {
 0%,
 100% {
  transform: translateX(0);
 }
 20%,
 60% {
  transform: translateX(-5px);
 }
 40%,
 80% {
  transform: translateX(5px);
 }
}

/* Efecto de escala al hacer click */
.memory-card:active:not(.flipped):not(.matched) {
 transform: scale(0.95);
 transition: transform 0.1s;
}

/* Para este efecto necesitarías añadir elementos de partícula en JS,
   pero aquí está el CSS base */
.particle {
 position: absolute;
 background: white;
 border-radius: 50%;
 pointer-events: none;
 animation: particleFade 1s forwards;
}

@keyframes particleFade {
 0% {
  opacity: 1;
  transform: translate(0, 0) scale(0);
 }
 100% {
  opacity: 0;
  transform: translate(var(--tx), var(--ty)) scale(1);
 }
}

/* Rotación 3D suave al pasar el cursor */
.memory-card:not(.flipped):not(.matched):hover .card-inner {
 transform: rotateX(var(--rotate-x, 0deg)) rotateY(var(--rotate-y, 0deg));
 transition: transform 0.2s;
}

/* Necesitarías añadir este JavaScript para calcular la rotación basada en la posición del cursor */
/*
  card.addEventListener('mousemove', (e) => {
    const rect = card.getBoundingClientRect();
    const x = e.clientX - rect.left - rect.width / 2;
    const y = e.clientY - rect.top - rect.height / 2;
    const rotateY = x / 10;
    const rotateX = -y / 10;
    card.style.setProperty('--rotate-y', `${rotateY}deg`);
    card.style.setProperty('--rotate-x', `${rotateX}deg`);
  });

  card.addEventListener('mouseleave', () => {
    card.style.setProperty('--rotate-y', '0deg');
    card.style.setProperty('--rotate-x', '0deg');
  });
*/

/* Sombra dinámica */
.memory-card:hover {
 --shadow-x: 10px;
 --shadow-y: 15px;
 --shadow-blur: 25px;
 box-shadow: var(--shadow-x) var(--shadow-y) var(--shadow-blur)
  var(--shadow-dark);
 transition: box-shadow 0.3s ease,
  transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
}

/* Efecto de ondulación al voltear */
@keyframes ripple {
 0% {
  transform: scale(0.8) rotateY(180deg);
  opacity: 0.8;
 }
 25% {
  transform: scale(1.1) rotateY(180deg);
  opacity: 1;
 }
 100% {
  transform: scale(1) rotateY(180deg);
  opacity: 1;
 }
}

.memory-card.flipped .card-inner {
 animation: flip 0.6s forwards, ripple 0.4s 0.6s forwards;
}

@keyframes flip {
 0% {
  transform: rotateY(0deg);
 }
 100% {
  transform: rotateY(180deg);
 }
}
